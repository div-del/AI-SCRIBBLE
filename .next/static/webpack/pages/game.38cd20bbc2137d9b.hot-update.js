"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/game",{

/***/ "./src/hooks/useSocket.ts":
/*!********************************!*\
  !*** ./src/hooks/useSocket.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSocket: function() { return /* binding */ useSocket; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! socket.io-client */ \"./node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var _store_gameStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/store/gameStore */ \"./src/store/gameStore.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\nconst useSocket = ()=>{\n    const [socket, setSocket] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const { startGame, submitGuess, addDrawCommand, addMessage, updateScoreboard, setTimeLeft, setWordHint, setCurrentRound, setCurrentDrawer, setIsRoundActive, endGame } = (0,_store_gameStore__WEBPACK_IMPORTED_MODULE_2__.useGameStore)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Use port 3001 as agreed\n        // Use port 3001 as agreed\n        const newSocket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_1__.io)(process.env.NEXT_PUBLIC_BACKEND_URL || \"http://localhost:3001\", {\n            transports: [\n                \"websocket\"\n            ],\n            withCredentials: true\n        });\n        newSocket.on(\"connect\", ()=>{\n            setIsConnected(true);\n            console.log(\"Connected to backend\");\n        });\n        newSocket.on(\"disconnect\", ()=>{\n            setIsConnected(false);\n            console.log(\"Disconnected from backend\");\n        });\n        newSocket.on(\"roomJoined\", (data)=>{\n            console.log(\"Joined room:\", data);\n        // Could update explicit player list if needed, but scoreboard covers it mostly\n        });\n        newSocket.on(\"roundStarted\", (data)=>{\n            // data: { round: number, drawer: string }\n            // Backend doesn't send timeLimit/wordHint/etc in start event clearly in code?\n            // Checking backend: io.to(roomId).emit('roundStarted', { round: newRound, drawer: drawerId === 'ai' ? 'AI' : room.players.get(drawerId)?.name });\n            // newRound object in backend has: id, drawerId, word, guesses, startTime\n            // We need to sync timeLimit (default 60s?), wordHint (from word).\n            const roundData = data.round;\n            setCurrentRound(data.round.id || 1);\n            // Drawer logic\n            // if drawer is AI, set special AI player?\n            const drawerName = data.drawer;\n            setCurrentDrawer({\n                id: roundData.drawerId,\n                name: drawerName,\n                isAI: roundData.drawerId === \"ai\"\n            });\n            setTimeLeft(60); // Default or from config? Backend doesn't seem to emit it.\n            setWordHint(\"_ \".repeat(roundData.word.length)); // Naive hint\n            setIsRoundActive(true);\n            _store_gameStore__WEBPACK_IMPORTED_MODULE_2__.useGameStore.getState().clearRoundState();\n        });\n        newSocket.on(\"timerUpdate\", (timeLeft)=>{\n            setTimeLeft(timeLeft);\n        });\n        newSocket.on(\"drawingReady\", (data)=>{\n            // data: { drawer: 'AI', svg: string, pngBase64: string }\n            if (data.svg) {\n                _store_gameStore__WEBPACK_IMPORTED_MODULE_2__.useGameStore.getState().setCurrentImage(data.svg);\n            } else if (data.pngBase64) {\n                _store_gameStore__WEBPACK_IMPORTED_MODULE_2__.useGameStore.getState().setCurrentImage(data.pngBase64);\n            }\n        });\n        // newGuess: { playerId, playerName, guess, isCorrect }\n        newSocket.on(\"newGuess\", (data)=>{\n            addMessage({\n                type: data.isCorrect ? \"correct\" : \"guess\",\n                playerId: data.playerId,\n                playerName: data.playerName || \"Unknown\",\n                text: data.guess,\n                timestamp: Date.now()\n            });\n            if (data.isCorrect) {\n            // Maybe show a special notification or toast?\n            }\n        });\n        // scoreboard: ScoreboardEntry[]\n        newSocket.on(\"scoreboard\", (data)=>{\n            updateScoreboard(data);\n        });\n        newSocket.on(\"roundEnded\", (data)=>{\n            setIsRoundActive(false);\n            addMessage({\n                type: \"system\",\n                playerId: \"system\",\n                playerName: \"System\",\n                text: \"Round Ended.\",\n                timestamp: Date.now()\n            });\n        });\n        // AI Guess event\n        newSocket.on(\"aiGuess\", (data)=>{\n            addMessage({\n                type: data.isCorrect ? \"correct\" : \"guess\",\n                playerId: \"ai\",\n                playerName: \"AI (\".concat(data.model, \")\"),\n                text: \"I guess it's \".concat(data.guess, \"!\"),\n                timestamp: Date.now()\n            });\n        });\n        newSocket.on(\"gameReset\", ()=>{\n            addMessage({\n                type: \"system\",\n                playerId: \"system\",\n                playerName: \"System\",\n                text: \"Game has been reset.\",\n                timestamp: Date.now()\n            });\n            _store_gameStore__WEBPACK_IMPORTED_MODULE_2__.useGameStore.getState().resetGame();\n        });\n        newSocket.on(\"roomError\", (msg)=>{\n            console.error(\"Room Error:\", msg);\n            alert(\"Room Error: \".concat(msg)); // Simple alert for now\n        });\n        newSocket.on(\"roundError\", (msg)=>{\n            console.error(\"Round Error:\", msg);\n            alert(\"Round Error: \".concat(msg));\n        });\n        setSocket(newSocket);\n        return ()=>{\n            newSocket.close();\n        };\n    }, []);\n    const handleStartGame = (playerName)=>{\n        if (socket) {\n            // Hardcoded room for now as per original intention or random\n            const roomId = \"test-room\";\n            socket.emit(\"joinRoom\", {\n                roomId,\n                playerName\n            });\n            startGame(playerName);\n        }\n    };\n    const handleStartRound = ()=>{\n        if (socket) {\n            // Starts the game loop\n            socket.emit(\"startRound\", {\n                roomId: \"test-room\"\n            });\n        }\n    };\n    const handleResetGame = ()=>{\n        if (socket) {\n            socket.emit(\"resetGame\", {\n                roomId: \"test-room\"\n            });\n        }\n    };\n    const handleSubmitGuess = (guess)=>{\n        if (socket) {\n            socket.emit(\"playerGuess\", {\n                roomId: \"test-room\",\n                guess\n            }); // Backend expects playerGuess matches listener\n            submitGuess(guess);\n        }\n    };\n    return {\n        socket,\n        isConnected,\n        startGame: handleStartGame,\n        startRound: handleStartRound,\n        resetGame: handleResetGame,\n        submitGuess: handleSubmitGuess\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZjFELE9BQU8yRCxJQUFJLENBQUMsWUFBWTtnQkFBRUQ7Z0JBQVFiO1lBQVc7WUFDN0N6QyxVQUFVeUM7UUFDWjtJQUNGO0lBRUEsTUFBTWUsbUJBQW1CO1FBQ3ZCLElBQUk1RCxRQUFRO1lBQ1YsdUJBQXVCO1lBQ3ZCQSxPQUFPMkQsSUFBSSxDQUFDLGNBQWM7Z0JBQUVELFFBQVE7WUFBWTtRQUNsRDtJQUNGO0lBRUEsTUFBTUcsa0JBQWtCO1FBQ3RCLElBQUk3RCxRQUFRO1lBQ1ZBLE9BQU8yRCxJQUFJLENBQUMsYUFBYTtnQkFBRUQsUUFBUTtZQUFZO1FBQ2pEO0lBQ0Y7SUFFQSxNQUFNSSxvQkFBb0IsQ0FBQ2Y7UUFDekIsSUFBSS9DLFFBQVE7WUFDVkEsT0FBTzJELElBQUksQ0FBQyxlQUFlO2dCQUFFRCxRQUFRO2dCQUFhWDtZQUFNLElBQUksK0NBQStDO1lBQzNHMUMsWUFBWTBDO1FBQ2Q7SUFDRjtJQUVBLE9BQU87UUFDTC9DO1FBQ0FFO1FBQ0FFLFdBQVdxRDtRQUNYTSxZQUFZSDtRQUNaUixXQUFXUztRQUNYeEQsYUFBYXlEO0lBQ2Y7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VTb2NrZXQudHM/MDQ2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBpbywgU29ja2V0IH0gZnJvbSAnc29ja2V0LmlvLWNsaWVudCc7XHJcbmltcG9ydCB7IHVzZUdhbWVTdG9yZSB9IGZyb20gJ0Avc3RvcmUvZ2FtZVN0b3JlJztcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VTb2NrZXQgPSAoKSA9PiB7XHJcbiAgY29uc3QgW3NvY2tldCwgc2V0U29ja2V0XSA9IHVzZVN0YXRlPFNvY2tldCB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFtpc0Nvbm5lY3RlZCwgc2V0SXNDb25uZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICBjb25zdCB7XHJcbiAgICBzdGFydEdhbWUsXHJcbiAgICBzdWJtaXRHdWVzcyxcclxuICAgIGFkZERyYXdDb21tYW5kLFxyXG4gICAgYWRkTWVzc2FnZSxcclxuICAgIHVwZGF0ZVNjb3JlYm9hcmQsXHJcbiAgICBzZXRUaW1lTGVmdCxcclxuICAgIHNldFdvcmRIaW50LFxyXG4gICAgc2V0Q3VycmVudFJvdW5kLFxyXG4gICAgc2V0Q3VycmVudERyYXdlcixcclxuICAgIHNldElzUm91bmRBY3RpdmUsXHJcbiAgICBlbmRHYW1lLFxyXG4gIH0gPSB1c2VHYW1lU3RvcmUoKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIFVzZSBwb3J0IDMwMDEgYXMgYWdyZWVkXHJcbiAgICAvLyBVc2UgcG9ydCAzMDAxIGFzIGFncmVlZFxyXG4gICAgY29uc3QgbmV3U29ja2V0ID0gaW8ocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMScsIHtcclxuICAgICAgdHJhbnNwb3J0czogWyd3ZWJzb2NrZXQnXSwgLy8gRm9yY2Ugd2Vic29ja2V0IHRvIGF2b2lkIDMwOCByZWRpcmVjdHMgd2l0aCBwb2xsaW5nXHJcbiAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcclxuICAgIH0pO1xyXG5cclxuICAgIG5ld1NvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcclxuICAgICAgc2V0SXNDb25uZWN0ZWQodHJ1ZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gYmFja2VuZCcpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbmV3U29ja2V0Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xyXG4gICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdEaXNjb25uZWN0ZWQgZnJvbSBiYWNrZW5kJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBuZXdTb2NrZXQub24oJ3Jvb21Kb2luZWQnLCAoZGF0YSkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZygnSm9pbmVkIHJvb206JywgZGF0YSk7XHJcbiAgICAgIC8vIENvdWxkIHVwZGF0ZSBleHBsaWNpdCBwbGF5ZXIgbGlzdCBpZiBuZWVkZWQsIGJ1dCBzY29yZWJvYXJkIGNvdmVycyBpdCBtb3N0bHlcclxuICAgIH0pO1xyXG5cclxuICAgIG5ld1NvY2tldC5vbigncm91bmRTdGFydGVkJywgKGRhdGEpID0+IHtcclxuICAgICAgLy8gZGF0YTogeyByb3VuZDogbnVtYmVyLCBkcmF3ZXI6IHN0cmluZyB9XHJcbiAgICAgIC8vIEJhY2tlbmQgZG9lc24ndCBzZW5kIHRpbWVMaW1pdC93b3JkSGludC9ldGMgaW4gc3RhcnQgZXZlbnQgY2xlYXJseSBpbiBjb2RlP1xyXG4gICAgICAvLyBDaGVja2luZyBiYWNrZW5kOiBpby50byhyb29tSWQpLmVtaXQoJ3JvdW5kU3RhcnRlZCcsIHsgcm91bmQ6IG5ld1JvdW5kLCBkcmF3ZXI6IGRyYXdlcklkID09PSAnYWknID8gJ0FJJyA6IHJvb20ucGxheWVycy5nZXQoZHJhd2VySWQpPy5uYW1lIH0pO1xyXG4gICAgICAvLyBuZXdSb3VuZCBvYmplY3QgaW4gYmFja2VuZCBoYXM6IGlkLCBkcmF3ZXJJZCwgd29yZCwgZ3Vlc3Nlcywgc3RhcnRUaW1lXHJcbiAgICAgIC8vIFdlIG5lZWQgdG8gc3luYyB0aW1lTGltaXQgKGRlZmF1bHQgNjBzPyksIHdvcmRIaW50IChmcm9tIHdvcmQpLlxyXG4gICAgICBjb25zdCByb3VuZERhdGEgPSBkYXRhLnJvdW5kO1xyXG4gICAgICBzZXRDdXJyZW50Um91bmQoZGF0YS5yb3VuZC5pZCB8fCAxKTtcclxuICAgICAgLy8gRHJhd2VyIGxvZ2ljXHJcbiAgICAgIC8vIGlmIGRyYXdlciBpcyBBSSwgc2V0IHNwZWNpYWwgQUkgcGxheWVyP1xyXG4gICAgICBjb25zdCBkcmF3ZXJOYW1lID0gZGF0YS5kcmF3ZXI7XHJcbiAgICAgIHNldEN1cnJlbnREcmF3ZXIoeyBpZDogcm91bmREYXRhLmRyYXdlcklkLCBuYW1lOiBkcmF3ZXJOYW1lLCBpc0FJOiByb3VuZERhdGEuZHJhd2VySWQgPT09ICdhaScgfSk7XHJcblxyXG4gICAgICBzZXRUaW1lTGVmdCg2MCk7IC8vIERlZmF1bHQgb3IgZnJvbSBjb25maWc/IEJhY2tlbmQgZG9lc24ndCBzZWVtIHRvIGVtaXQgaXQuXHJcbiAgICAgIHNldFdvcmRIaW50KCdfICcucmVwZWF0KHJvdW5kRGF0YS53b3JkLmxlbmd0aCkpOyAvLyBOYWl2ZSBoaW50XHJcbiAgICAgIHNldElzUm91bmRBY3RpdmUodHJ1ZSk7XHJcblxyXG4gICAgICB1c2VHYW1lU3RvcmUuZ2V0U3RhdGUoKS5jbGVhclJvdW5kU3RhdGUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIG5ld1NvY2tldC5vbigndGltZXJVcGRhdGUnLCAodGltZUxlZnQ6IG51bWJlcikgPT4ge1xyXG4gICAgICBzZXRUaW1lTGVmdCh0aW1lTGVmdCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBuZXdTb2NrZXQub24oJ2RyYXdpbmdSZWFkeScsIChkYXRhKSA9PiB7XHJcbiAgICAgIC8vIGRhdGE6IHsgZHJhd2VyOiAnQUknLCBzdmc6IHN0cmluZywgcG5nQmFzZTY0OiBzdHJpbmcgfVxyXG4gICAgICBpZiAoZGF0YS5zdmcpIHtcclxuICAgICAgICB1c2VHYW1lU3RvcmUuZ2V0U3RhdGUoKS5zZXRDdXJyZW50SW1hZ2UoZGF0YS5zdmcpO1xyXG4gICAgICB9IGVsc2UgaWYgKGRhdGEucG5nQmFzZTY0KSB7XHJcbiAgICAgICAgdXNlR2FtZVN0b3JlLmdldFN0YXRlKCkuc2V0Q3VycmVudEltYWdlKGRhdGEucG5nQmFzZTY0KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gbmV3R3Vlc3M6IHsgcGxheWVySWQsIHBsYXllck5hbWUsIGd1ZXNzLCBpc0NvcnJlY3QgfVxyXG4gICAgbmV3U29ja2V0Lm9uKCduZXdHdWVzcycsIChkYXRhKSA9PiB7XHJcbiAgICAgIGFkZE1lc3NhZ2Uoe1xyXG4gICAgICAgIHR5cGU6IGRhdGEuaXNDb3JyZWN0ID8gJ2NvcnJlY3QnIDogJ2d1ZXNzJyxcclxuICAgICAgICBwbGF5ZXJJZDogZGF0YS5wbGF5ZXJJZCxcclxuICAgICAgICBwbGF5ZXJOYW1lOiBkYXRhLnBsYXllck5hbWUgfHwgJ1Vua25vd24nLFxyXG4gICAgICAgIHRleHQ6IGRhdGEuZ3Vlc3MsXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKGRhdGEuaXNDb3JyZWN0KSB7XHJcbiAgICAgICAgLy8gTWF5YmUgc2hvdyBhIHNwZWNpYWwgbm90aWZpY2F0aW9uIG9yIHRvYXN0P1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBzY29yZWJvYXJkOiBTY29yZWJvYXJkRW50cnlbXVxyXG4gICAgbmV3U29ja2V0Lm9uKCdzY29yZWJvYXJkJywgKGRhdGEpID0+IHtcclxuICAgICAgdXBkYXRlU2NvcmVib2FyZChkYXRhKTtcclxuICAgIH0pO1xyXG5cclxuICAgIG5ld1NvY2tldC5vbigncm91bmRFbmRlZCcsIChkYXRhKSA9PiB7XHJcbiAgICAgIHNldElzUm91bmRBY3RpdmUoZmFsc2UpO1xyXG4gICAgICBhZGRNZXNzYWdlKHtcclxuICAgICAgICB0eXBlOiAnc3lzdGVtJyxcclxuICAgICAgICBwbGF5ZXJJZDogJ3N5c3RlbScsXHJcbiAgICAgICAgcGxheWVyTmFtZTogJ1N5c3RlbScsXHJcbiAgICAgICAgdGV4dDogJ1JvdW5kIEVuZGVkLicsXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFJIEd1ZXNzIGV2ZW50XHJcbiAgICBuZXdTb2NrZXQub24oJ2FpR3Vlc3MnLCAoZGF0YSkgPT4ge1xyXG4gICAgICBhZGRNZXNzYWdlKHtcclxuICAgICAgICB0eXBlOiBkYXRhLmlzQ29ycmVjdCA/ICdjb3JyZWN0JyA6ICdndWVzcycsXHJcbiAgICAgICAgcGxheWVySWQ6ICdhaScsXHJcbiAgICAgICAgcGxheWVyTmFtZTogYEFJICgke2RhdGEubW9kZWx9KWAsXHJcbiAgICAgICAgdGV4dDogYEkgZ3Vlc3MgaXQncyAke2RhdGEuZ3Vlc3N9IWAsXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbmV3U29ja2V0Lm9uKCdnYW1lUmVzZXQnLCAoKSA9PiB7XHJcbiAgICAgIGFkZE1lc3NhZ2Uoe1xyXG4gICAgICAgIHR5cGU6ICdzeXN0ZW0nLFxyXG4gICAgICAgIHBsYXllcklkOiAnc3lzdGVtJyxcclxuICAgICAgICBwbGF5ZXJOYW1lOiAnU3lzdGVtJyxcclxuICAgICAgICB0ZXh0OiAnR2FtZSBoYXMgYmVlbiByZXNldC4nLFxyXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxyXG4gICAgICB9KTtcclxuICAgICAgdXNlR2FtZVN0b3JlLmdldFN0YXRlKCkucmVzZXRHYW1lKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBuZXdTb2NrZXQub24oJ3Jvb21FcnJvcicsIChtc2cpID0+IHtcclxuICAgICAgY29uc29sZS5lcnJvcignUm9vbSBFcnJvcjonLCBtc2cpO1xyXG4gICAgICBhbGVydChgUm9vbSBFcnJvcjogJHttc2d9YCk7IC8vIFNpbXBsZSBhbGVydCBmb3Igbm93XHJcbiAgICB9KTtcclxuXHJcbiAgICBuZXdTb2NrZXQub24oJ3JvdW5kRXJyb3InLCAobXNnKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1JvdW5kIEVycm9yOicsIG1zZyk7XHJcbiAgICAgIGFsZXJ0KGBSb3VuZCBFcnJvcjogJHttc2d9YCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBzZXRTb2NrZXQobmV3U29ja2V0KTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBuZXdTb2NrZXQuY2xvc2UoKTtcclxuICAgIH07XHJcbiAgfSwgW10pO1xyXG5cclxuICBjb25zdCBoYW5kbGVTdGFydEdhbWUgPSAocGxheWVyTmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgICBpZiAoc29ja2V0KSB7XHJcbiAgICAgIC8vIEhhcmRjb2RlZCByb29tIGZvciBub3cgYXMgcGVyIG9yaWdpbmFsIGludGVudGlvbiBvciByYW5kb21cclxuICAgICAgY29uc3Qgcm9vbUlkID0gXCJ0ZXN0LXJvb21cIjtcclxuICAgICAgc29ja2V0LmVtaXQoJ2pvaW5Sb29tJywgeyByb29tSWQsIHBsYXllck5hbWUgfSk7XHJcbiAgICAgIHN0YXJ0R2FtZShwbGF5ZXJOYW1lKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVTdGFydFJvdW5kID0gKCkgPT4ge1xyXG4gICAgaWYgKHNvY2tldCkge1xyXG4gICAgICAvLyBTdGFydHMgdGhlIGdhbWUgbG9vcFxyXG4gICAgICBzb2NrZXQuZW1pdCgnc3RhcnRSb3VuZCcsIHsgcm9vbUlkOiBcInRlc3Qtcm9vbVwiIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVJlc2V0R2FtZSA9ICgpID0+IHtcclxuICAgIGlmIChzb2NrZXQpIHtcclxuICAgICAgc29ja2V0LmVtaXQoJ3Jlc2V0R2FtZScsIHsgcm9vbUlkOiBcInRlc3Qtcm9vbVwiIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZVN1Ym1pdEd1ZXNzID0gKGd1ZXNzOiBzdHJpbmcpID0+IHtcclxuICAgIGlmIChzb2NrZXQpIHtcclxuICAgICAgc29ja2V0LmVtaXQoJ3BsYXllckd1ZXNzJywgeyByb29tSWQ6IFwidGVzdC1yb29tXCIsIGd1ZXNzIH0pOyAvLyBCYWNrZW5kIGV4cGVjdHMgcGxheWVyR3Vlc3MgbWF0Y2hlcyBsaXN0ZW5lclxyXG4gICAgICBzdWJtaXRHdWVzcyhndWVzcyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHNvY2tldCxcclxuICAgIGlzQ29ubmVjdGVkLFxyXG4gICAgc3RhcnRHYW1lOiBoYW5kbGVTdGFydEdhbWUsXHJcbiAgICBzdGFydFJvdW5kOiBoYW5kbGVTdGFydFJvdW5kLFxyXG4gICAgcmVzZXRHYW1lOiBoYW5kbGVSZXNldEdhbWUsXHJcbiAgICBzdWJtaXRHdWVzczogaGFuZGxlU3VibWl0R3Vlc3MsXHJcbiAgfTtcclxufTsiXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJpbyIsInVzZUdhbWVTdG9yZSIsInVzZVNvY2tldCIsInNvY2tldCIsInNldFNvY2tldCIsImlzQ29ubmVjdGVkIiwic2V0SXNDb25uZWN0ZWQiLCJzdGFydEdhbWUiLCJzdWJtaXRHdWVzcyIsImFkZERyYXdDb21tYW5kIiwiYWRkTWVzc2FnZSIsInVwZGF0ZVNjb3JlYm9hcmQiLCJzZXRUaW1lTGVmdCIsInNldFdvcmRIaW50Iiwic2V0Q3VycmVudFJvdW5kIiwic2V0Q3VycmVudERyYXdlciIsInNldElzUm91bmRBY3RpdmUiLCJlbmRHYW1lIiwibmV3U29ja2V0IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0JBQ0tFTkRfVVJMIiwidHJhbnNwb3J0cyIsIndpdGhDcmVkZW50aWFscyIsIm9uIiwiY29uc29sZSIsImxvZyIsImRhdGEiLCJyb3VuZERhdGEiLCJyb3VuZCIsImlkIiwiZHJhd2VyTmFtZSIsImRyYXdlciIsImRyYXdlcklkIiwibmFtZSIsImlzQUkiLCJyZXBlYXQiLCJ3b3JkIiwibGVuZ3RoIiwiZ2V0U3RhdGUiLCJjbGVhclJvdW5kU3RhdGUiLCJ0aW1lTGVmdCIsInN2ZyIsInNldEN1cnJlbnRJbWFnZSIsInBuZ0Jhc2U2NCIsInR5cGUiLCJpc0NvcnJlY3QiLCJwbGF5ZXJJZCIsInBsYXllck5hbWUiLCJ0ZXh0IiwiZ3Vlc3MiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwibW9kZWwiLCJyZXNldEdhbWUiLCJtc2ciLCJlcnJvciIsImFsZXJ0IiwiY2xvc2UiLCJoYW5kbGVTdGFydEdhbWUiLCJyb29tSWQiLCJlbWl0IiwiaGFuZGxlU3RhcnRSb3VuZCIsImhhbmRsZVJlc2V0R2FtZSIsImhhbmRsZVN1Ym1pdEd1ZXNzIiwic3RhcnRSb3VuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/hooks/useSocket.ts\n"));

/***/ })

});